import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Mic, Camera, Send, Sparkles, Settings, Heart } from 'lucide-react';

const AICharacterEngine = () => {
  const [character, setCharacter] = useState(null);
  const [currentEmotion, setCurrentEmotion] = useState('neutral');
  const [isListening, setIsListening] = useState(false);
  const [messages, setMessages] = useState([]);
  const [inputText, setInputText] = useState('');
  const [isGeneratingCharacter, setIsGeneratingCharacter] = useState(false);
  const [characterConfig, setCharacterConfig] = useState({
    style: 'anime',
    personality: 'friendly',
    hairColor: 'brown',
    eyeColor: 'blue'
  });

  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const characterDataRef = useRef(null);

  // ê°ì •ë³„ í‘œì • ë³€í™” ë§¤í•‘
  const emotionMapping = {
    neutral: { eyeScale: 1.0, mouthCurve: 0, blushAlpha: 0, eyebrowAngle: 0 },
    happy: { eyeScale: 0.8, mouthCurve: 0.3, blushAlpha: 0.2, eyebrowAngle: 0.1 },
    sad: { eyeScale: 1.2, mouthCurve: -0.2, blushAlpha: 0, eyebrowAngle: -0.2 },
    surprised: { eyeScale: 1.4, mouthCurve: 0.1, blushAlpha: 0.1, eyebrowAngle: 0.3 },
    angry: { eyeScale: 0.7, mouthCurve: -0.3, blushAlpha: 0, eyebrowAngle: -0.4 },
    embarrassed: { eyeScale: 0.9, mouthCurve: 0.1, blushAlpha: 0.6, eyebrowAngle: 0.1 },
    excited: { eyeScale: 1.1, mouthCurve: 0.4, blushAlpha: 0.3, eyebrowAngle: 0.2 }
  };

  // ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ ì—”ì§„
  class CharacterAnimationEngine {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.baseImage = null;
      this.currentTransform = {
        headTilt: 0,
        eyeScale: 1.0,
        mouthCurve: 0,
        blushAlpha: 0,
        eyebrowAngle: 0,
        breathingOffset: 0
      };
      this.animationTime = 0;
      this.isAnimating = true;
    }

    async loadCharacterImage(imageUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          this.baseImage = img;
          this.analyzeImageFeatures(img);
          resolve();
        };
        img.src = imageUrl;
      });
    }

    analyzeImageFeatures(image) {
      // ì´ë¯¸ì§€ ë¶„ì„ì„ í†µí•œ ì–¼êµ´ íŠ¹ì§•ì  ì¶”ì¶œ (ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜)
      const features = {
        faceCenter: { x: this.canvas.width * 0.5, y: this.canvas.height * 0.4 },
        eyeLeft: { x: this.canvas.width * 0.42, y: this.canvas.height * 0.35 },
        eyeRight: { x: this.canvas.width * 0.58, y: this.canvas.height * 0.35 },
        mouth: { x: this.canvas.width * 0.5, y: this.canvas.height * 0.48 },
        leftCheek: { x: this.canvas.width * 0.35, y: this.canvas.height * 0.42 },
        rightCheek: { x: this.canvas.width * 0.65, y: this.canvas.height * 0.42 }
      };
      characterDataRef.current = features;
    }

    updateEmotion(emotion) {
      const targetTransform = emotionMapping[emotion] || emotionMapping.neutral;
      this.animateToTransform(targetTransform);
    }

    animateToTransform(target) {
      const duration = 500; // ms
      const startTime = Date.now();
      const startTransform = { ...this.currentTransform };

      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = this.easeInOutCubic(progress);

        // ë¶€ë“œëŸ¬ìš´ ì „í™˜
        Object.keys(target).forEach(key => {
          if (key in startTransform) {
            this.currentTransform[key] = startTransform[key] + 
              (target[key] - startTransform[key]) * easeProgress;
          }
        });

        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      };

      animate();
    }

    easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }

    render() {
      if (!this.baseImage || !this.isAnimating) return;

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // í˜¸í¡ ì• ë‹ˆë©”ì´ì…˜
      this.animationTime += 0.02;
      this.currentTransform.breathingOffset = Math.sin(this.animationTime) * 2;

      // ê¸°ë³¸ ìºë¦­í„° ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
      this.ctx.save();
      
      // ë¨¸ë¦¬ ê¸°ìš¸ê¸°ì™€ í˜¸í¡ íš¨ê³¼
      this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
      this.ctx.rotate(this.currentTransform.headTilt);
      this.ctx.translate(0, this.currentTransform.breathingOffset);
      this.ctx.drawImage(
        this.baseImage, 
        -this.baseImage.width / 2, 
        -this.baseImage.height / 2
      );

      this.ctx.restore();

      // í‘œì • ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
      this.renderExpressionOverlay();
      
      requestAnimationFrame(() => this.render());
    }

    renderExpressionOverlay() {
      if (!characterDataRef.current) return;

      const features = characterDataRef.current;
      
      // ë¸”ëŸ¬ì‹œ íš¨ê³¼
      if (this.currentTransform.blushAlpha > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = this.currentTransform.blushAlpha;
        this.ctx.fillStyle = '#ffb3ba';
        
        // ì–‘ ë³¼ì— ë¸”ëŸ¬ì‹œ
        this.drawBlush(features.leftCheek.x, features.leftCheek.y);
        this.drawBlush(features.rightCheek.x, features.rightCheek.y);
        
        this.ctx.restore();
      }

      // ëˆˆ íš¨ê³¼ (í™•ëŒ€/ì¶•ì†Œ)
      this.renderEyeEffects(features);
      
      // ì… ê³¡ì„  íš¨ê³¼
      this.renderMouthEffect(features);
    }

    drawBlush(x, y) {
      const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 20);
      gradient.addColorStop(0, 'rgba(255, 179, 186, 0.6)');
      gradient.addColorStop(1, 'rgba(255, 179, 186, 0)');
      
      this.ctx.fillStyle = gradient;
      this.ctx.beginPath();
      this.ctx.arc(x, y, 20, 0, Math.PI * 2);
      this.ctx.fill();
    }

    renderEyeEffects(features) {
      // ëˆˆ í¬ê¸° ë³€í™” íš¨ê³¼ (ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜)
      this.ctx.save();
      this.ctx.globalAlpha = 0.3;
      this.ctx.fillStyle = this.currentTransform.eyeScale > 1.1 ? '#fff' : 'rgba(0,0,0,0.2)';
      
      const eyeRadius = Math.abs(this.currentTransform.eyeScale - 1) * 5;
      
      this.ctx.beginPath();
      this.ctx.arc(features.eyeLeft.x, features.eyeLeft.y, eyeRadius, 0, Math.PI * 2);
      this.ctx.fill();
      
      this.ctx.beginPath();
      this.ctx.arc(features.eyeRight.x, features.eyeRight.y, eyeRadius, 0, Math.PI * 2);
      this.ctx.fill();
      
      this.ctx.restore();
    }

    renderMouthEffect(features) {
      if (Math.abs(this.currentTransform.mouthCurve) < 0.1) return;
      
      this.ctx.save();
      this.ctx.strokeStyle = this.currentTransform.mouthCurve > 0 ? '#ff6b9d' : '#4a90e2';
      this.ctx.lineWidth = 2;
      this.ctx.globalAlpha = 0.6;
      
      const curve = this.currentTransform.mouthCurve * 20;
      
      this.ctx.beginPath();
      this.ctx.moveTo(features.mouth.x - 15, features.mouth.y);
      this.ctx.quadraticCurveTo(features.mouth.x, features.mouth.y - curve, features.mouth.x + 15, features.mouth.y);
      this.ctx.stroke();
      
      this.ctx.restore();
    }

    startAnimation() {
      this.isAnimating = true;
      this.render();
    }

    stopAnimation() {
      this.isAnimating = false;
    }
  }

  // ìºë¦­í„° ìƒì„± í•¨ìˆ˜
  const generateCharacter = async () => {
    setIsGeneratingCharacter(true);
    try {
      // GPT-4o ì´ë¯¸ì§€ ìƒì„± API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
      const prompt = `anime style character portrait, ${characterConfig.personality} personality, 
        ${characterConfig.hairColor} hair, ${characterConfig.eyeColor} eyes, 
        school uniform, high quality, detailed face, neutral expression`;
      
      // ì‹¤ì œë¡œëŠ” OpenAI DALL-E APIë¥¼ í˜¸ì¶œ
      // const response = await fetch('/api/generate-character', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ prompt, style: characterConfig.style })
      // });
      
      // ì‹œë®¬ë ˆì´ì…˜: ëœë¤ ì• ë‹ˆë©”ì´ì…˜ ìºë¦­í„° ì´ë¯¸ì§€
      const sampleImages = [
        'data:image/svg+xml;base64,' + btoa(`
          <svg width="300" height="400" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <radialGradient id="face" cx="50%" cy="40%" r="50%">
                <stop offset="0%" style="stop-color:#ffeaa7"/>
                <stop offset="100%" style="stop-color:#fdcb6e"/>
              </radialGradient>
            </defs>
            <rect width="300" height="400" fill="#f8f9fa"/>
            <ellipse cx="150" cy="160" rx="80" ry="100" fill="url(#face)"/>
            <circle cx="130" cy="140" r="8" fill="#2d3436"/>
            <circle cx="170" cy="140" r="8" fill="#2d3436"/>
            <path d="M 135 180 Q 150 190 165 180" stroke="#e17055" stroke-width="2" fill="none"/>
            <path d="M 100 100 Q 150 80 200 100" stroke="#${characterConfig.hairColor === 'brown' ? '8b4513' : '000'}" stroke-width="20" fill="none"/>
          </svg>
        `)
      ];
      
      setTimeout(() => {
        setCharacter({
          imageUrl: sampleImages[0],
          personality: characterConfig.personality,
          name: 'ë¯¸ì¹´'
        });
        setIsGeneratingCharacter(false);
      }, 2000);
      
    } catch (error) {
      console.error('ìºë¦­í„° ìƒì„± ì‹¤íŒ¨:', error);
      setIsGeneratingCharacter(false);
    }
  };

  // ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
  useEffect(() => {
    if (character && canvasRef.current) {
      const engine = new CharacterAnimationEngine(canvasRef.current);
      animationRef.current = engine;
      
      engine.loadCharacterImage(character.imageUrl).then(() => {
        engine.startAnimation();
      });

      return () => {
        if (animationRef.current) {
          animationRef.current.stopAnimation();
        }
      };
    }
  }, [character]);

  // ê°ì • ë³€í™” íš¨ê³¼
  useEffect(() => {
    if (animationRef.current) {
      animationRef.current.updateEmotion(currentEmotion);
    }
  }, [currentEmotion]);

  // ë©”ì‹œì§€ ì „ì†¡ ì²˜ë¦¬
  const sendMessage = async () => {
    if (!inputText.trim()) return;

    const userMessage = { type: 'user', content: inputText };
    setMessages(prev => [...prev, userMessage]);
    
    // ê°ì • ë¶„ì„ ë° ì‘ë‹µ ìƒì„± (ì‹œë®¬ë ˆì´ì…˜)
    const emotions = ['happy', 'excited', 'neutral', 'surprised'];
    const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
    setCurrentEmotion(randomEmotion);
    
    // AI ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
    setTimeout(() => {
      const responses = [
        'ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ ê¸°ë¶„ì´ ì–´ë– ì„¸ìš”?',
        'ê·¸ë ‡êµ°ìš”! ë” ìì„¸íˆ ë§ì”€í•´ ì£¼ì„¸ìš”.',
        'ì •ë§ í¥ë¯¸ë¡œìš´ ì´ì•¼ê¸°ë„¤ìš”!',
        'ì €ë„ ê·¸ëŸ° ìƒê°ì´ì—ìš”!'
      ];
      
      const aiMessage = { 
        type: 'ai', 
        content: responses[Math.floor(Math.random() * responses.length)],
        emotion: randomEmotion
      };
      setMessages(prev => [...prev, aiMessage]);
    }, 1000);
    
    setInputText('');
  };

  // ìŒì„± ì¸ì‹ ì²˜ë¦¬
  const toggleListening = () => {
    setIsListening(!isListening);
    if (!isListening) {
      setCurrentEmotion('surprised');
    } else {
      setCurrentEmotion('neutral');
    }
  };

  return (
    <div className="flex flex-col h-screen bg-gradient-to-b from-purple-100 to-blue-100">
      {/* ìºë¦­í„° ë””ìŠ¤í”Œë ˆì´ ì˜ì—­ */}
      <div className="flex-1 relative overflow-hidden">
        {!character ? (
          <div className="flex flex-col items-center justify-center h-full p-6">
            <div className="bg-white rounded-2xl p-8 shadow-lg text-center max-w-sm">
              <Sparkles className="w-16 h-16 mx-auto mb-4 text-purple-500" />
              <h2 className="text-2xl font-bold mb-4">AI ìºë¦­í„° ìƒì„±</h2>
              <p className="text-gray-600 mb-6">ë‚˜ë§Œì˜ AI ìºë¦­í„°ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”!</p>
              
              <div className="space-y-4 mb-6">
                <select
                  value={characterConfig.personality}
                  onChange={(e) => setCharacterConfig(prev => ({...prev, personality: e.target.value}))}
                  className="w-full p-2 border rounded-lg"
                >
                  <option value="friendly">ì¹œê·¼í•œ</option>
                  <option value="cheerful">í™œë°œí•œ</option>
                  <option value="gentle">ì°¨ë¶„í•œ</option>
                  <option value="mysterious">ì‹ ë¹„ë¡œìš´</option>
                </select>
                
                <select
                  value={characterConfig.hairColor}
                  onChange={(e) => setCharacterConfig(prev => ({...prev, hairColor: e.target.value}))}
                  className="w-full p-2 border rounded-lg"
                >
                  <option value="brown">ê°ˆìƒ‰</option>
                  <option value="black">ê²€ì€ìƒ‰</option>
                  <option value="blonde">ê¸ˆë°œ</option>
                  <option value="pink">ë¶„í™ìƒ‰</option>
                </select>
              </div>
              
              <button
                onClick={generateCharacter}
                disabled={isGeneratingCharacter}
                className="w-full bg-purple-500 text-white py-3 rounded-lg font-medium disabled:opacity-50"
              >
                {isGeneratingCharacter ? 'ìƒì„± ì¤‘...' : 'ìºë¦­í„° ìƒì„±'}
              </button>
            </div>
          </div>
        ) : (
          <div className="relative h-full">
            <canvas
              ref={canvasRef}
              width={400}
              height={500}
              className="absolute inset-0 mx-auto"
              style={{ maxWidth: '100%', height: 'auto' }}
            />
            
            {/* ê°ì • í‘œì‹œ */}
            <div className="absolute top-4 right-4 bg-white/80 rounded-full px-3 py-1 text-sm">
              ğŸ˜Š {currentEmotion}
            </div>
            
            {/* ìºë¦­í„° ì •ë³´ */}
            <div className="absolute top-4 left-4 bg-white/80 rounded-lg p-3">
              <div className="flex items-center gap-2">
                <Heart className="w-4 h-4 text-red-500" />
                <span className="font-medium">{character.name}</span>
              </div>
              <div className="text-sm text-gray-600">{character.personality}</div>
            </div>
          </div>
        )}
      </div>

      {/* ì±„íŒ… ì¸í„°í˜ì´ìŠ¤ */}
      {character && (
        <div className="bg-white border-t border-gray-200">
          {/* ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸ */}
          <div className="max-h-32 overflow-y-auto p-4 space-y-2">
            {messages.map((msg, idx) => (
              <div
                key={idx}
                className={`flex ${msg.type === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <div
                  className={`max-w-xs px-3 py-2 rounded-lg text-sm ${
                    msg.type === 'user'
                      ? 'bg-purple-500 text-white'
                      : 'bg-gray-100 text-gray-800'
                  }`}
                >
                  {msg.content}
                </div>
              </div>
            ))}
          </div>

          {/* ì…ë ¥ ì¸í„°í˜ì´ìŠ¤ */}
          <div className="p-4 border-t border-gray-100">
            <div className="flex items-center gap-2">
              <button
                onClick={toggleListening}
                className={`p-2 rounded-full ${
                  isListening ? 'bg-red-500 text-white' : 'bg-gray-200 text-gray-600'
                }`}
              >
                <Mic className="w-5 h-5" />
              </button>
              
              <button
                onClick={() => setCurrentEmotion('surprised')}
                className="p-2 rounded-full bg-gray-200 text-gray-600"
              >
                <Camera className="w-5 h-5" />
              </button>
              
              <input
                type="text"
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                className="flex-1 px-4 py-2 border border-gray-300 rounded-full focus:outline-none focus:border-purple-500"
              />
              
              <button
                onClick={sendMessage}
                className="p-2 rounded-full bg-purple-500 text-white"
              >
                <Send className="w-5 h-5" />
              </button>
            </div>
          </div>

          {/* ê°ì • í…ŒìŠ¤íŠ¸ ë²„íŠ¼ë“¤ */}
          <div className="p-4 border-t border-gray-100">
            <div className="flex gap-2 flex-wrap">
              {Object.keys(emotionMapping).map(emotion => (
                <button
                  key={emotion}
                  onClick={() => setCurrentEmotion(emotion)}
                  className={`px-3 py-1 rounded-full text-xs ${
                    currentEmotion === emotion
                      ? 'bg-purple-500 text-white'
                      : 'bg-gray-200 text-gray-600'
                  }`}
                >
                  {emotion}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AICharacterEngine;